{"name":"Cakephp behavior slug","body":"#Slug Behavior.\r\n###Enables a model object to sluggable behavior.\r\n\r\n# Comportamiento para URLs Amigables.\r\n\r\nEn ocasiones queremos que nuestros _registros_ sean accedidos por un campo distinto al **ID**, por ejemplo en el sitio web tenemos **artículos** los cuales tiene los siguientes campos:\r\n\r\n - id - Identificador (campo auto incrementable)\r\n - nombre - Es campo es único también.\r\n - contenido - texto el cual podría ser vació.\r\n\r\nSi queremos definir las acciones `ver`, `editar` y `borrar` para nuestros articulos, [el estándar del **cakephp**](http://book.cakephp.org/2.0/en/development/routing.html#default-routing) nos dice que para acceder al primer, articulo el cual se llama \"algún articulo\" tendríamos las siguientes **URLs**:\r\n\r\n\r\n\t#visualizando un articulo\r\n\thttp://mi-sitio/articulos/ver/1\r\n\r\n\t#Editando un articulo\r\n\thttp://mi-sitio/articulos/editar/1\r\n\t\r\n\t#Borrando un articulo\r\n\thttp://mi-sitio/articulos/borrar/1\r\n\r\n \r\nImaginemos que queremos hacer que nuestros artículos se pudieran acceder a partir de las siguientes **URLs**:\r\n\t\r\n\t#visualizando un articulo\r\n\thttp://mi-sitio/articulos/ver/algun-articulo.html\r\n\t\r\n\t#Editando un articulo\r\n\thttp://mi-sitio/articulos/editar/algun-articulo.html\r\n\t\r\n\t#Borrando un articulo\r\n\thttp://mi-sitio/articulos/borrar/algun-articulo.html\r\n\r\n\r\nPrecisamente este `Slug Behavior` nos permite hacer esto con [cakephp](http://cakephp.org/), ¿te interesa? continua leyendo...\r\n\r\n\r\n# Instrucciones de uso.\r\n\r\n## Descargar el paquete.\r\n\r\nUsted puede descargar la versión mas reciente este proyecto desde la siguientes **URLs**:\r\n\r\n<a href=\"https://github.com/mundoSICA/Magento_1.6.x_translation_es_MX/tarball/master\" class=\"button icon arrowdown\">Download as <b>.tar.gz</b></a>\r\n<a href=\"https://github.com/mundoSICA/Magento_1.6.x_translation_es_MX/zipball/master\" class=\"button icon arrowdown\">Download as <b>.zip</b></a>\r\n\r\n## Agrega el SlugBehavior en tu aplicación.\r\n\r\nAgrega el archivo `SlugBehavior.php` en la carpeta `app/Model/Behavior/`.\r\n\r\n## Edita tu tabla de base de datos.\r\n\r\nEn este caso teníamos artículos con los siguientes campos.\r\n\r\n - id - Identificador (campo auto incrementable)\r\n - nombre - Es campo es único también.\r\n - contenido - texto el cual podría ser vació.\r\n\r\nEs importante comentar que el campo nombre es único ahora solo faltaria agregar otro campo único con el nombre `slug_dst`.\r\n\r\nComo **Tip** te recomiendo configuraren tu  base de datos el campo `slug_dst` como indice, esto por cuestiones de rendimiento ya que al generar `slug_dst` como indice el motor **SQL** genera mas rápido las consultas:\r\n\r\n      ALTER TABLE `articulos` ADD INDEX ( `slug_dst` ) ;\r\n\r\n## Descripción de argumentos:\r\n\r\n#### slug\\_src:\r\n\r\nPor defecto toma el campo que hayamos definido como [**displayField**](http://book.cakephp.org/view/1062/displayField),ademas este campo deberá ser un campo único en la tabla, el cual sufrirá la trasformación **slug** para ser almacenado como `slug_dst`.\r\n\r\n```php\r\n<?php\r\n\t#Definiendo el campo $displayField\r\n\tvar $displayField = 'titulo';\r\n\t#Agregamos el comportamiento `Slug` entre la lista de comportamientos\r\n\tvar $actsAs = array('Slug');\r\n```\r\n\r\n#### Definición explicita del campo a trasformar\r\n\r\n```php\r\n<?php\r\n\t#Agregamos el comportamiento `Slug` entre la lista de\r\n\t#comportamientos, esta vez con defincion explita del\r\n\t#campo a traformar slug_src\r\n\tvar $actsAs = array('Slug'=>array('slug_src' => 'titulo'));\r\n```\r\n\r\n\r\nCabe mencionar que si definimos el **displayField** y también definimos explícitamente el campo a trasformar `slug_src` la opción que tomara sera la explicita, veamos un ejemplo:\r\n\r\n```php\r\n<?php\r\n\tvar $displayField = 'nombre';\r\n\tvar $actsAs = array('Slug'=>array('slug_src' => 'titulo'));\r\n```\r\n\r\nEl campo que tomara para trasformarlo sera `titulo` (por encima de `nombre`) ya que de esta forma estaremos diciendo explícitamente que el `slug_src` deberá ser el campo `titulo`.\r\n\r\n\r\n#### slug\\_dst \"destino del campo slug\":\r\n\r\nDeberás agregar el campo slug_dst como indice:\r\n\r\n```sql\r\n\tALTER TABLE `talleres` ADD `slug_dst` VARCHAR( 80 ) NOT NULL AFTER `id` ,\r\n\tADD INDEX ( `slug_dst` ) \r\n```\r\n\r\nEl resultado de la trasformación **slug**  la cual en este caso seria 'algun-articulo', se almacenara automáticamente en este campo y desde ahí nuestro sistema podrá responder desde una url similar a:\r\n\r\n\t#accediendo a alguna acción para el articulo \"algún articulo\"\r\n\thttp://mi-sitio/articulos/alguna_accion/algun-articulo\r\n\r\n\r\n> El comportamiento Slug revisa si la tabla contiene el campo `slug_dst` para almacenar esta información automáticamente.\r\n\r\n\r\n#### slug\\_dst explícito.\r\n\r\nAhora sí por alguna razón necesitas(ó simplemente deseas) que almacenar el valor `slug_dst`  en algún campo distinto por ejemplo `seo_url`, lo que tienes que hacer es definir explícitamente el campo `slug_dst`.\r\n\r\n```php \r\n<?php\r\n\tvar $actsAs = array('Slug'=>array('slug_dst' => 'seo_url'));\r\n```\r\n\r\nEn este caso el valor 'algun-articulo' quedaria almacenado en el campo `seo_url` de nuestra tabla `articulos`.\r\n\r\n\r\n#### max\\_len Longitud máxima:\r\n\r\nLongitud máxima que puede llegar a tomar `slug_dst`.\r\n\r\n```php\r\n<?php\r\n\tvar $actsAs = array('Slug'=>array('max_len'=>30));\r\n\t#esto nos genera\r\n\tArticulo.slug_dst = \"este-es-un-articulo-sobre-el-c\"\r\n```\r\n\r\n#### wd\\_separator separador de palabras:\r\n\r\nSeparador de palabras `wd_separator` (words separator) es el carácter separador de palabras,el valor por defecto es el guion alto(-), pero tu puedes definir otro por ejemplo:\r\n\r\n```php\r\n<?php\r\n\tvar $actsAs = array('Slug'=>array('wd_separator'=>'_'));\r\n```\r\n\r\nEsto nos generaría en `slug_dst` el valor de `algun_articulo`(en lugar de `algun-articulo`)\r\n\r\n```php\r\n<?php\r\n\tvar $actsAs = array('Slug'=>array('wd_separator'=>'.'));\r\n```\r\n\r\nEsto nos generaría en `slug_dst` el valor de `algun.articulo`.\r\n\r\n\r\n#### extension\\_active Activación de extensión:\r\n\r\nPor defecto false, si activamos este campo agrega la extensión '.html', reduciendo 5 caracteres el campo max\\_len (la longitud de '.html').\r\n\r\n```php\r\n\tvar $actsAs = array('Slug'=>array('extension_active'=>true));\r\n```\r\n\r\nEn este caso el valor `slug_dst` seria `algun-articulo.html` agregando al final la extensión `.html`.\r\n\r\n\r\n## Ejemplo concreto de configuración:\r\n\r\nEntonces definimos la siguiente tabla:\r\n\r\n```sql\r\n\tCREATE TABLE IF NOT EXISTS `articulos` (\r\n\t\t`id` INT( 5 ) PRIMARY KEY NOT NULL UNIQUE AUTO_INCREMENT,\r\n\t\t`nombre` VARCHAR( 80 ) NOT NULL UNIQUE,\r\n\t\t`slug_dst` VARCHAR( 50 ) NOT NULL UNIQUE,\r\n\t\t`contenido` VARCHAR( 150 ) DEFAULT NULL\r\n\t) ENGINE=InnoDB DEFAULT CHARSET=latin1 AUTO_INCREMENT=1 ;\r\n```\r\n\r\n\r\nEn nuestro modelo de **Articulo**(`APP/Model/Behavior/SlugBehavior.php`) definimos el comportamiento **slug** de la siguiente manera:\r\n```php\r\n<?php\r\n\tclass Articulo extends AppModel{\r\n\t\tvar $name = 'Articulo';\r\n\t\t\r\n\t\t#campo a mostrar\r\n\t\tvar $displayField = 'nombre';\r\n\t\t\r\n\t\t#Definición del comportamiento slug\r\n\t\tvar $actsAs = array( 'slug'=>array('extension_active'=>true));\r\n\t}\r\n```\r\n\r\nEl código anterior hace que el campo nombre(definido como `displayField`) sera trasformado con la forma `slug` y sera almacenado en el campo `slug_dst` para que de esta forma podamos realizar las consultas.\r\n\r\n### Accediendo a los valores desde slug\r\n\r\nFinalmente en nuestro controlador podemos llamar a las funciones slug:\r\n\r\n```php\r\n<?php\r\n\t#leyendo un registro a partir del slug\r\n\t$this->Articulo->readBySlug($slug);\r\n\r\n\t#obteniendo el id del articulo a partir del slug\r\n\t$id = $this->Articulo->primaryKeyBySlug(($slug));\r\n```\r\n\t\r\nPara las demás funciones el comportamiento slug realiza las operaciones necesarias por ejemplo si deseamos guardar un registro basta con hacer:\r\n\r\n```php\r\n<?php\r\n\t#agregando\r\n\t$this->Articulo->save($this->data);\r\n```\r\n\r\nDonde en $this->data deberá contener el campo `displayField`(o el `slug_sr` que hallamos definido) y automáticamente el comportamiento nos va a generar el `slug_dst`, _¿fácil no?_.\r\n\r\n\r\n\r\n## Cambios futuros.\r\n\r\nEste proyecto actualmente esta en la versión `1.0` los cambios en la siguiente versión( 1.1 ) se esperan que sean:\r\n\r\n - Agregar **callBack slug_prefix**.\r\n - Agregar **callBack slug_postfix**.\r\n - Soporte para extensiones distintas a html, p.e.(`xhml`, `xml`).\r\n\r\nPor el momento no he abordado el problema si tienes alguna idea bienvenida sea\r\n\r\n\r\n## Hackers.\r\n\r\nSi quieres comprender mas te remiendo seguir la siguiente documentación:\r\n\r\n> <http://book.cakephp.org/2.0/en/models/behaviors.html>\r\n\r\n","tagline":"Enables a model object to sluggable behavior.","google":"UA-32824744-1","note":"Don't delete this file! It's used internally to help with page regeneration."}